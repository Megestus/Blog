import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as e,d as r,f as t,o as n}from"./app-1tH4GCLc.js";const i={},c=r("p",null,'Draw Call 是一个术语，用于描述图形处理单元（GPU）接收并执行渲染命令的过程。在计算机图形和游戏开发中，每次渲染操作，如渲染一个网格或一个物体到屏幕上，都需要通过调用图形API（例如OpenGL或DirectX）来告诉GPU "绘制" 这些对象。每个这样的调用就称为一个 "Draw Call"。',-1),s=t('<div class="image-preview"><img src="https://megestus-1309556466.cos.ap-shanghai.myqcloud.com/img/202407190022588.png" style="width:50% !important;"></div><h3 id="draw-call的重要性" tabindex="-1"><a class="header-anchor" href="#draw-call的重要性"><span>Draw Call的重要性</span></a></h3><ul><li>性能影响：Draw Calls是影响游戏和实时应用性能的关键因素之一。每个Draw Call都涉及CPU和GPU之间的通信，这种通信是有开销的。如果一个场景有大量的Draw Calls，它可能会导致性能瓶颈，特别是在CPU较弱的系统上。</li><li>批处理优化：为了减少Draw Call的数量并提高性能，开发者通常会尽量通过各种优化技术来减少这些调用的次数。例如，静态物体的网格和纹理可以被合并，这样它们就可以在一个Draw Call中一起渲染，而不是分别渲染。</li><li>实例化：如前所述，使用实例化渲染是减少Draw Calls的一种有效方法。通过实例化，可以用单个Draw Call渲染多个对象的副本，只要这些对象共享相同的几何体和材料属性。</li></ul><h2 id="draw-call的工作流程" tabindex="-1"><a class="header-anchor" href="#draw-call的工作流程"><span>Draw Call的工作流程</span></a></h2><ul><li>准备阶段：CPU负责处理游戏逻辑，包括输入、物理计算、动画等，并决定哪些对象需要被渲染以及它们的属性。</li><li>提交Draw Call：一旦确定了渲染对象，CPU会准备相应的渲染数据（如网格数据、纹理、着色器等），并通过调用图形API将这些渲染命令发送给GPU。</li><li>渲染执行：GPU接收到Draw Call后，执行渲染命令，处理顶点数据，应用着色器，执行纹理映射和光照计算，最终输出到屏幕上。</li></ul><p>简而言之，Draw Call是图形开发中的一个基本概念，它涉及CPU向GPU发送渲染指令的过程。优化Draw Calls的数量是提高图形应用性能的关键策略之一。理解和优化Draw Calls对于任何涉及3D渲染的开发者来说都是非常重要的。</p><h2 id="draw-call优化策略" tabindex="-1"><a class="header-anchor" href="#draw-call优化策略"><span>Draw Call优化策略：</span></a></h2><h3 id="批处理合并-batching" tabindex="-1"><a class="header-anchor" href="#批处理合并-batching"><span>批处理合并（Batching）：</span></a></h3><ul><li>静态批处理：把多个静态对象（不会在运行时改变的对象）合并成一个大的网格，这样它们就可以在一个Draw Call中被渲染。</li><li>动态批处理：对动态对象（如动画角色）使用类似的技术，但通常更加复杂，因为每个对象可能会有不同的变换。</li></ul><h3 id="使用实例化渲染-instancing" tabindex="-1"><a class="header-anchor" href="#使用实例化渲染-instancing"><span>使用实例化渲染（Instancing）：</span></a></h3><p>对于多次重复出现在场景中的相同对象，如建筑物、树木或装饰物，使用实例化可以大大减少Draw Calls。</p><h3 id="材料和纹理合并-material-and-texture-atlasing" tabindex="-1"><a class="header-anchor" href="#材料和纹理合并-material-and-texture-atlasing"><span>材料和纹理合并（Material and Texture Atlasing）：</span></a></h3><ul><li>尽量减少材料的数量。多个对象使用同一材料和纹理可以一起渲染。</li><li>纹理集合（Texture Atlasing）是一个常用技术，把多个小纹理合并到一张大图（图集）中，这样多个对象就可以共享同一个纹理而被一起渲染。</li></ul><h3 id="减少过度绘制-overdraw-reduction" tabindex="-1"><a class="header-anchor" href="#减少过度绘制-overdraw-reduction"><span>减少过度绘制（Overdraw Reduction）：</span></a></h3><p>优化场景的渲染顺序，确保先绘制最远的对象，再绘制最近的对象，减少像素的重复绘制。</p><h3 id="lod-level-of-detail-技术" tabindex="-1"><a class="header-anchor" href="#lod-level-of-detail-技术"><span>LOD（Level of Detail）技术：</span></a></h3><p>对远处的对象使用较低详细级别的模型和纹理，减少渲染负担。</p><h2 id="draw-call的流程涉及的内存类型" tabindex="-1"><a class="header-anchor" href="#draw-call的流程涉及的内存类型"><span>Draw Call的流程涉及的内存类型</span></a></h2><p>Draw Call自身并不是存储在显存中的。Draw Call是指CPU向GPU发送的一个命令，告诉GPU绘制一定数量的图形元素（如顶点或图元）。这个过程涉及几个不同的组件和内存类型的交互，但Draw Call本身更多的是一个过程或动作，而非数据本身被存储的实体。</p><h3 id="draw-call的流程涉及的内存类型-1" tabindex="-1"><a class="header-anchor" href="#draw-call的流程涉及的内存类型-1"><span>Draw Call的流程涉及的内存类型：</span></a></h3><ul><li>系统内存（RAM）： <ul><li>这里通常存储了游戏或应用程序的数据，包括3D模型的原始顶点数据、纹理、动画数据等。</li></ul></li><li>显存（VRAM）： <ul><li>当3D对象和纹理被加载进场景时，它们的数据会被传输到显存中。显存是GPU直接访问的内存，访问速度快，适合存储需要快速渲染的数据。</li></ul></li><li>命令缓冲区： <ul><li>当CPU准备好渲染命令后，这些命令会被组织成一系列的GPU可理解的指令，存储在命令缓冲区中。命令缓冲区可能位于CPU的内存中，也可能位于GPU的内存中，具体取决于具体的硬件和驱动实现。</li></ul></li></ul><h4 id="draw-call的处理" tabindex="-1"><a class="header-anchor" href="#draw-call的处理"><span>Draw Call的处理：</span></a></h4><p>当执行Draw Call时，CPU会生成一系列的指令或命令，这些命令描述了如何渲染特定的图形元素。这些命令随后被发送到GPU。GPU接收这些命令，并从显存中获取必要的数据（如顶点数据和纹理），执行渲染管线的各个阶段，最终将结果输出到屏幕上。</p><p>因此，虽然Draw Call涉及的数据（如顶点信息和纹理）确实存储在显存中，但Draw Call本身作为渲染命令的过程，其相关的指令通常是存储在命令缓冲区中，并由GPU按需处理。这个过程确保了渲染操作的高效执行，但Draw Call本身并不直接存储在显存中。</p><h2 id="推荐的资源" tabindex="-1"><a class="header-anchor" href="#推荐的资源"><span>推荐的资源：</span></a></h2><h4 id="书籍" tabindex="-1"><a class="header-anchor" href="#书籍"><span>书籍：</span></a></h4><ul><li>《Real-Time Rendering》: 这本书详细介绍了各种实时渲染技术，包括如何有效地管理Draw Calls。</li><li>《Game Engine Architecture》 by Jason Gregory: 提供了一章关于图形管线和优化技巧的讨论。</li></ul><h4 id="在线资源" tabindex="-1"><a class="header-anchor" href="#在线资源"><span>在线资源：</span></a></h4><ul><li><a href="https://learn.unity.com/" target="_blank" rel="noopener noreferrer">Unity Learn</a> 和 <a href="https://dev.epicgames.com/" target="_blank" rel="noopener noreferrer">Unreal Engine Documentation</a>：这些官方教程提供了大量关于如何在这些引擎中优化Draw Calls的具体指南。</li><li><a href="https://developer.nvidia.com/" target="_blank" rel="noopener noreferrer">NVIDIA Developer Zone</a> 和 <a href="https://www.amd.com/zh-cn/developer.html" target="_blank" rel="noopener noreferrer">AMD Developer Central</a>：这些网站提供了专门针对硬件优化的技术文章和指南。</li></ul><h4 id="博客和文章" tabindex="-1"><a class="header-anchor" href="#博客和文章"><span>博客和文章：</span></a></h4><ul><li>Gamasutra, GameDev.net, 和 Medium 上有许多关于Draw Calls优化的专业文章和博客帖子。</li></ul><p>通过这些资源和策略，可以深入了解如何优化Draw Calls，从而提高3D应用的性能。</p>',32);function o(d,h){return n(),l("div",null,[c,e(" more "),s])}const u=a(i,[["render",o],["__file","DrawCall_note.html.vue"]]),D=JSON.parse('{"path":"/engine/unreal/Note/DrawCall_note.html","title":"Draw Call","lang":"zh-CN","frontmatter":{"title":"Draw Call","description":"Draw Call 是一个术语，用于描述图形处理单元（GPU）接收并执行渲染命令的过程。在计算机图形和游戏开发中，每次渲染操作，如渲染一个网格或一个物体到屏幕上，都需要通过调用图形API（例如OpenGL或DirectX）来告诉GPU \\"绘制\\" 这些对象。每个这样的调用就称为一个 \\"Draw Call\\"。","icon":"iconfont alicon-unreal","category":"unreal","tag":["unreal"],"date":"2024-07-18T00:00:00.000Z","cover":null,"head":[["meta",{"property":"og:url","content":"https:///about.md/blog/engine/unreal/Note/DrawCall_note.html"}],["meta",{"property":"og:site_name","content":"Megestus"}],["meta",{"property":"og:title","content":"Draw Call"}],["meta",{"property":"og:description","content":"Draw Call 是一个术语，用于描述图形处理单元（GPU）接收并执行渲染命令的过程。在计算机图形和游戏开发中，每次渲染操作，如渲染一个网格或一个物体到屏幕上，都需要通过调用图形API（例如OpenGL或DirectX）来告诉GPU \\"绘制\\" 这些对象。每个这样的调用就称为一个 \\"Draw Call\\"。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-18T16:28:16.000Z"}],["meta",{"property":"article:author","content":"Megestus"}],["meta",{"property":"article:tag","content":"unreal"}],["meta",{"property":"article:published_time","content":"2024-07-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-18T16:28:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Draw Call\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-18T16:28:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Megestus\\",\\"url\\":\\"https://github.com/Megestus\\"}]}"]]},"headers":[{"level":3,"title":"Draw Call的重要性","slug":"draw-call的重要性","link":"#draw-call的重要性","children":[]},{"level":2,"title":"Draw Call的工作流程","slug":"draw-call的工作流程","link":"#draw-call的工作流程","children":[]},{"level":2,"title":"Draw Call优化策略：","slug":"draw-call优化策略","link":"#draw-call优化策略","children":[{"level":3,"title":"批处理合并（Batching）：","slug":"批处理合并-batching","link":"#批处理合并-batching","children":[]},{"level":3,"title":"使用实例化渲染（Instancing）：","slug":"使用实例化渲染-instancing","link":"#使用实例化渲染-instancing","children":[]},{"level":3,"title":"材料和纹理合并（Material and Texture Atlasing）：","slug":"材料和纹理合并-material-and-texture-atlasing","link":"#材料和纹理合并-material-and-texture-atlasing","children":[]},{"level":3,"title":"减少过度绘制（Overdraw Reduction）：","slug":"减少过度绘制-overdraw-reduction","link":"#减少过度绘制-overdraw-reduction","children":[]},{"level":3,"title":"LOD（Level of Detail）技术：","slug":"lod-level-of-detail-技术","link":"#lod-level-of-detail-技术","children":[]}]},{"level":2,"title":"Draw Call的流程涉及的内存类型","slug":"draw-call的流程涉及的内存类型","link":"#draw-call的流程涉及的内存类型","children":[{"level":3,"title":"Draw Call的流程涉及的内存类型：","slug":"draw-call的流程涉及的内存类型-1","link":"#draw-call的流程涉及的内存类型-1","children":[]}]},{"level":2,"title":"推荐的资源：","slug":"推荐的资源","link":"#推荐的资源","children":[]}],"git":{"createdTime":1721320096000,"updatedTime":1721320096000,"contributors":[{"name":"Megestus","email":"2624203622@qq.com","commits":1}]},"filePathRelative":"engine/unreal/Note/DrawCall_note.md","localizedDate":"2024年7月18日","excerpt":"<p>Draw Call 是一个术语，用于描述图形处理单元（GPU）接收并执行渲染命令的过程。在计算机图形和游戏开发中，每次渲染操作，如渲染一个网格或一个物体到屏幕上，都需要通过调用图形API（例如OpenGL或DirectX）来告诉GPU \\"绘制\\" 这些对象。每个这样的调用就称为一个 \\"Draw Call\\"。</p>\\n","autoDesc":true}');export{u as comp,D as data};
